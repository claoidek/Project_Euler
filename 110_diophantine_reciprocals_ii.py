# Finds the smallest n for which the equation 1/x + 1/y = 1/n has more than four
# million solutions.

# For the equation to hold, we must have x,y > n, so we can rewrite as:
# 1/(n+a) + 1/(n+b) = 1/n
# Which after rearranging and simplifying gives:
# n^2 = ab
# So the answer will be the smallest n^2 that has over four million pairs of
# factors a,b

# We can reduce the the search space by noting that if n has a pair of factors
# c,d then cn,d and c,dn will both be factors of n^2
# This means that for every two divisors of n, we can generate four divisors of
# n^2
# The only exception to this is the pair 1,n which generates the two pairs 1,n^2
# and n,n which only add three divisors of n^2
# Therefore, if n has p divisors, n^2 has 2p - 1

# We also have that the number of divisors of a number n with prime
# factorisation (p1^a1)*(p2^a2)*...*(pk^ak) is given by:
# (a1 + 1)*(a2 + 1)*...*(ak + 1)
# This is shown in Equation 3 here:
# http://mathworld.wolfram.com/DivisorFunction.html
# This means that the number of divisors of n^2 is: 
# (2*a1 + 1)*(2*a2 + 1)*...*(2*ak + 1)

# We also note that we must have a1 >= a2 >= ... >= ak because otherwise the
# powers could be rearranged to give a smaller number with exactly the same
# number of divisors.

import time
import math

# Recursive function for generating all sequences of a given length which are
# non-monotonically decreasing. This is used for generating all possible powers
# of primes that could generate a valid solution, given the power of two.
def generate_decreasing_sequence(sequences,sequence,length):
    if(len(sequence) == length):
        sequences.append(sequence)
    else:
        for digit in range(sequence[-1] + 1):
            new_sequence = sequence + [digit]
            generate_decreasing_sequence(sequences, new_sequence, length)

start = time.time()

# Since each solution has two divisors, our threshold for the number of divisors
# is twice the minimum number of solutions.
threshold = 2*4000000
# The product of the first fifteen primes generates a number with the required
# number of solutions, so the solution must be smaller than this.
primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
min_found = math.prod(primes) + 1

power_of_two = 0
solution_found = False
solution_found_in_last_cycle = False
index = 0

# Once we find a solution we continue until we have a complete cycle of attempts
# with a given power of two without finding a better solution. This has not been
# mathematically proven to give the correct answer, but it seems to work.
while(not(solution_found and not(solution_found_in_last_cycle))):
    solution_found_in_last_cycle = False
    power_of_two += 1
    prime_power_sequences = []
    generate_decreasing_sequence(prime_power_sequences,[power_of_two],len(primes))       
    for prime_powers_used in prime_power_sequences:
        # Find the number of solutions generated by our prime power sequence.
        num_solutions = 1
        for prime in range(len(primes)):
            num_solutions *= 2 * prime_powers_used[prime] + 1
        # If the number of solutions is big enough, check if we have found a
        # smaller number.
        if(num_solutions >= threshold):
            solution = 1
            for prime in range(len(primes)):
                solution *= primes[prime] ** prime_powers_used[prime]
            if(solution < min_found):
                min_found = solution
                solution_found = True
                solution_found_in_last_cycle = True

end = time.time()

print(min_found)
print("Time taken: ", end-start, "s", sep="")
